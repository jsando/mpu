package asm

import (
	"bufio"
	"encoding/hex"
	"fmt"
	"os"
	"sort"
	"strings"
)

// WriteListing prints the generated bytes next to the original source, ie
// an assembly listing.
func WriteListing(inputs []string, linker *Linker) error {
	stmt := linker.statements
	pc := 0
	for _, path := range inputs {
		f, err := os.Open(path)
		if err != nil {
			return err
		}
		scanner := bufio.NewScanner(f)
		line := 1
		fmt.Printf("%4d: 0x%04x  ---------- %s ----------\n", line, pc, f.Name())
		var bytes []byte
		for scanner.Scan() {
			if stmt != nil && stmt.File() != path {
				break
			}
			if stmt != nil {
				pc = stmt.PcStart()
			}
			bytes, stmt = getBytes(line, stmt, linker)
			text := scanner.Text()
			if len(bytes) == 0 {
				fmt.Printf("%4d: 0x%04x  %-12s %s\n", line, pc, "", text)
				line++
			} else {
				hexLines, newPc := toHexStrings(bytes, pc)
				fmt.Printf("%4d: %s %s\n", line, hexLines[0], text)
				for i := 1; i < len(hexLines); i++ {
					fmt.Printf("    : %s\n", hexLines[i])
				}
				pc = newPc
				line++
			}
		}
	}
	fmt.Printf("\n\nGlobal Symbols\n")
	var keys []string
	for k := range linker.symbols.symbols {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		v := linker.symbols.symbols[k]
		if !strings.Contains(k, ".") {
			fmt.Printf("  %-50s: 0x%04x (%d)\n", k, v.value, v.value)
		}
	}
	return nil
}

func toHexStrings(bytes []byte, pc int) ([]string, int) {
	var lines []string
	for {
		remaining := len(bytes)
		if remaining == 0 {
			break
		}
		n := 5
		if remaining < 5 {
			n = remaining
		}
		slice := bytes[:n]
		bytes = bytes[n:]
		s := fmt.Sprintf("0x%04x  %-12s", pc, hex.EncodeToString(slice))
		lines = append(lines, s)
		pc += n
	}
	return lines, pc
}

func getBytes(fileLine int, s Statement, l *Linker) ([]byte, Statement) {
	var buf []byte
	if s != nil {
		if fileLine < s.Line() {
			return buf, s // stick with s, not ready to print it yet
		}
		pcStart := s.PcStart()
		pcEnd := s.PcEnd()

		// fast-forward until statement matches line number, but beware of new file
		path := s.File()
		for s != nil && s.Line() <= fileLine && s.File() == path {
			pcEnd = s.PcEnd()
			s = s.Next()
		}
		if pcStart < pcEnd {
			buf = l.code[pcStart:pcEnd]
		}
	}
	return buf, s
}
