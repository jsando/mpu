package asm

import (
	"bufio"
	"encoding/hex"
	"fmt"
	"io"
	"os"
	"sort"
	"strings"
)

// WriteListing prints the generated bytes next to the original source, ie
// an assembly listing.
func WriteListing(inputs []*os.File, linker *Linker) error {
	frag := linker.fragment
	pc := 0
	for _, f := range inputs {
		_, err := f.Seek(0, io.SeekStart)
		if err != nil {
			panic(err)
		}
		scanner := bufio.NewScanner(f)
		line := 1
		fmt.Printf("%4d: 0x%04x  ---------- %s ----------\n", line, pc, f.Name())
		for scanner.Scan() {
			if frag != nil {
				pc = frag.pcStart
			}
			text := scanner.Text()
			if frag == nil || line < frag.line {
				fmt.Printf("%4d: 0x%04x  %-12s %s\n", line, pc, "", text)
				line++
				continue
			}
			if frag != nil {
				bytesFor := linker.BytesFor(frag)
				if len(bytesFor) > 5 {
					bytesFor = bytesFor[:5]
				}
				bytes := hex.EncodeToString(bytesFor)
				fmt.Printf("%4d: 0x%04x  %-12s %s\n", line, pc, bytes, text)
				line++
				frag = frag.next
			}
		}
	}
	fmt.Printf("\n\nGlobal Symbols\n")
	var keys []string
	for k := range linker.symbols.symbols {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		v := linker.symbols.symbols[k]
		if !strings.Contains(k, ".") {
			fmt.Printf("  %-50s: 0x%04x\n", k, v.value)
		}
	}
	return nil
}
